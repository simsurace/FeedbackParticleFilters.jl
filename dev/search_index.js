var documenterSearchIndex = {"docs":
[{"location":"#FeedbackParticleFilters.jl-1","page":"Home","title":"FeedbackParticleFilters.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A package for using feedback particle filters in nonlinear stochastic filtering and data assimilation problems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n \"getting_started.md\",\n]\nDepth = 1","category":"page"},{"location":"#What-are-feedback-particle-filters?-1","page":"Home","title":"What are feedback particle filters?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Feedback particle filters (FPFs) are a class of sample-based numerical algorithms to approximate the conditional distribution in a nonlinear filtering problem. In contrast to conventional particle filters, which use importance weights, FPFs use feedback control to let the observations guide the particles to the appropriate position.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Further background reading:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n \"filtering.md\",\n \"fpf.md\",\n]\nDepth = 1","category":"page"},{"location":"#Package-features-1","page":"Home","title":"Package features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package's aim is to provide a versatile and efficient feedback particle filter implementation in Julia, with abstractions to flexibly construct, run, and analyze feedback particle filters for a variety of uni- and multivariate filtering problems with both diffusion and point process observations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In particular, the following features are planned to be implemented in FeedbackParticleFilters:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Types for hidden state and observation models: diffusions, Poisson processes, etc.\nA variety of gain estimation methods\nAutomatic filter deployment and simulation of the state and filtering equations\nStoring of intermediate (trajectory) data from simulation\nAn interface to the powerful solvers from the DifferentialEquations package ","category":"page"},{"location":"getting_started/#Getting-started-1","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/#Installation-1","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"Use the built-in package manager:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"using Pkg\nPkg.add(\"FeedbackParticleFilters\")","category":"page"},{"location":"getting_started/#Basic-usage-1","page":"Getting started","title":"Basic usage","text":"","category":"section"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"To load the package, use the command:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"using FeedbackParticleFilters","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"Set up a basic one-dimensional linear-Gaussian continuous-time filtering problem:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"using Distributions\nstate_model = ScalarDiffusionStateModel(x->-x, x->sqrt(2.), Normal())\nobs_model   = ScalarDiffusionObservationModel(x->x)\n\nfilt_prob = ContinuousTimeFilteringProblem(state_model, obs_model)","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"Once the filtering problem is defined, you can use it to perform a variety of tasks.","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"For example, you may initialize an ensemble of N=100 particles:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"ensemble = UnweightedParticleEnsemble(state_model, 100)","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"The following generates a Poisson equation for the gain using the ensemble above. The equation is solved using the semigroup gain estimation method.","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"eq = GainEquation(state_model, obs_model, ensemble)\nmethod = SemigroupMethod(1E-1,1E-2)\nsolve!(eq, method)","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"The gain at the particle locations is stored in eq.gain. These low-level building blocks can then be used to write custom numerical implementations. The package also comes with methods to automatically simulate a given filtering problem:","category":"page"},{"location":"getting_started/#","page":"Getting started","title":"Getting started","text":"filter = FPF(filt_prob, method, 100)\nsimulation = ContinuousTimeSimulation(filt_prob, filter, 10000, 0.01)\nrun!(simulation)","category":"page"},{"location":"filtering/#Brief-intro-to-filtering-1","page":"Brief intro to filtering","title":"Brief intro to filtering","text":"","category":"section"},{"location":"filtering/#","page":"Brief intro to filtering","title":"Brief intro to filtering","text":"Here's some inline maths: sqrtn1 + x + x^2 + ldots.","category":"page"},{"location":"filtering/#","page":"Brief intro to filtering","title":"Brief intro to filtering","text":"fracnk(n - k) = binomnk","category":"page"},{"location":"fpf/#Feedback-particle-filters-1","page":"Feedback particle filters","title":"Feedback particle filters","text":"","category":"section"},{"location":"basic/#Basic-setup-1","page":"Basic setup","title":"Basic setup","text":"","category":"section"},{"location":"basic/#","page":"Basic setup","title":"Basic setup","text":"CurrentModule = FeedbackParticleFilters","category":"page"},{"location":"basic/#","page":"Basic setup","title":"Basic setup","text":"Pages = [\"basic.md\"]","category":"page"},{"location":"basic/#Defining-a-filtering-problem-1","page":"Basic setup","title":"Defining a filtering problem","text":"","category":"section"},{"location":"basic/#Choosing-a-suitable-filtering-algorithm-1","page":"Basic setup","title":"Choosing a suitable filtering algorithm","text":"","category":"section"},{"location":"basic/#Doing-stuff...-1","page":"Basic setup","title":"Doing stuff...","text":"","category":"section"},{"location":"hidden/#Hidden-state-models-1","page":"Hidden state models","title":"Hidden state models","text":"","category":"section"},{"location":"hidden/#","page":"Hidden state models","title":"Hidden state models","text":"CurrentModule = FeedbackParticleFilters","category":"page"},{"location":"hidden/#","page":"Hidden state models","title":"Hidden state models","text":"HiddenStateModel\nstate_dim\nstate_type\ntime_type\ninitial_condition\ninitialize\npropagate!","category":"page"},{"location":"hidden/#FeedbackParticleFilters.HiddenStateModel","page":"Hidden state models","title":"FeedbackParticleFilters.HiddenStateModel","text":"HiddenStateModel{S, T<:TimeType} <: AbstractModel{S}\n\nAbstract type for any model of the hidden state of type S.\n\n\n\n\n\n","category":"type"},{"location":"hidden/#FeedbackParticleFilters.state_dim","page":"Hidden state models","title":"FeedbackParticleFilters.state_dim","text":"state_dim(problem::AbstractFilteringProblem)\n\nReturn the dimensionality of the hidden state in problem.\n\n\n\n\n\nstate_dim(model::HiddenStateModel)\n\nReturns the dimensionality of the hidden state in model.\n\n\n\n\n\n","category":"function"},{"location":"hidden/#FeedbackParticleFilters.state_type","page":"Hidden state models","title":"FeedbackParticleFilters.state_type","text":"state_type(arg)\n\nReturns the type of the hidden state in arg.  Supported argument types:\n\nAny subtype of AbstractModel\nAny subtype of AbstractFilteringProblem\n\n\n\n\n\nstate_type(model::HiddenStateModel)\n\nReturns the data type of the hidden state in model.\n\n\n\n\n\n","category":"function"},{"location":"hidden/#FeedbackParticleFilters.initial_condition","page":"Hidden state models","title":"FeedbackParticleFilters.initial_condition","text":"initial_condition(model::HiddenStateModel)\n\nReturns the specification of the initial condition in model. This is either a fixed value or a samplable distribution.\n\n\n\n\n\n","category":"function"},{"location":"hidden/#FeedbackParticleFilters.initialize","page":"Hidden state models","title":"FeedbackParticleFilters.initialize","text":"initialize(model::HiddenStateModel)\n\nReturns a sample from the initial distribution of model.\n\n\n\n\n\n","category":"function"},{"location":"hidden/#FeedbackParticleFilters.propagate!","page":"Hidden state models","title":"FeedbackParticleFilters.propagate!","text":"propagate!(state[s], model::HiddenStateModel[, dt])\n\nPropagates the state(s) according to the model. For ContinuousTime' models, a time stepdt' has to be provided. Multiple states are given as a matrix with columns corresponding to states, and are processed i.i.d.\n\n\n\n\n\npropagate!(sfs, filtering_problem, filtering_algorithm; dt) --> sfs\n\nPropagates the system and filter states for one time-step according to the specified filtering problem and algorithm.\n\n\n\n\n\n","category":"function"},{"location":"hidden/#","page":"Hidden state models","title":"Hidden state models","text":"Pages = [\"hidden.md\"]","category":"page"},{"location":"hidden/#Diffusion-processes-1","page":"Hidden state models","title":"Diffusion processes","text":"","category":"section"},{"location":"hidden/#","page":"Hidden state models","title":"Hidden state models","text":"DiffusionStateModel\nLinearDiffusionStateModel\nScalarDiffusionStateModel\ndrift_function\ndiffusion_function\nnoise_dim","category":"page"},{"location":"hidden/#FeedbackParticleFilters.LinearDiffusionStateModel","page":"Hidden state models","title":"FeedbackParticleFilters.LinearDiffusionStateModel","text":"LinearDiffusionStateModel(A, B; init)\n\nReturns a linear diffusion process hidden state model dX_t = A X_t dt + B dW_t with appropriately sized matrices A and B.\n\nOptional argument init stands for the initial condition of the process, which is either\n\nA vector of length n for a fixed (deterministic) initial condition\nA Distributions.Sampleable type for a random initial condition\n\nIf argument init is left out, it is set to either \n\na multivariate normal distribution with covariance matrix set to the stationary variance, if it exists\nthe zero vector\n\n\n\n\n\n","category":"type"},{"location":"hidden/#FeedbackParticleFilters.drift_function","page":"Hidden state models","title":"FeedbackParticleFilters.drift_function","text":"drift_function(model)\n\nReturns the drift function f of the diffusion model dX_t = f(X_t)dt + g(X_t)dW_t.\n\n\n\n\n\n","category":"function"},{"location":"hidden/#FeedbackParticleFilters.diffusion_function","page":"Hidden state models","title":"FeedbackParticleFilters.diffusion_function","text":"diffusion_function(model)\n\nReturns the diffusion function g of the diffusion model dX_t = f(X_t)dt + g(X_t)dW_t.\n\n\n\n\n\n","category":"function"},{"location":"hidden/#FeedbackParticleFilters.noise_dim","page":"Hidden state models","title":"FeedbackParticleFilters.noise_dim","text":"noise_dim(model)\n\nReturns the dimension of the Brownian motion W_t in the diffusion model dX_t = f(X_t)dt + g(X_t)dW_t.\n\n\n\n\n\n","category":"function"},{"location":"observation/#Observation-models-1","page":"Observation models","title":"Observation models","text":"","category":"section"},{"location":"observation/#","page":"Observation models","title":"Observation models","text":"CurrentModule = FeedbackParticleFilters","category":"page"},{"location":"observation/#","page":"Observation models","title":"Observation models","text":"ObservationModel\nobs_dim\nobs_type\ntime_type\nemit!","category":"page"},{"location":"observation/#FeedbackParticleFilters.ObservationModel","page":"Observation models","title":"FeedbackParticleFilters.ObservationModel","text":"ObservationModel{S1, S2, T} <: AbstractModel{S2}\n\nAbstract type for any model of observations of type S2 and hidden states of type S1.\n\nCalling the model samples a new observation. For discrete-time or static models, \n\nmodel(x)\n\nreturns a new observation based on hidden state x.\n\nFor continuous-time models,\n\nmodel(x, dt)\n\nreturns a new observation based on hidden state x and time-step dt.\n\nIf x is a vector of state_type elements or a batch matrix, an observation is generated for each element of the batch.\n\n\n\n\n\n","category":"type"},{"location":"observation/#FeedbackParticleFilters.obs_dim","page":"Observation models","title":"FeedbackParticleFilters.obs_dim","text":"obs_dim(problem::AbstractFilteringProblem)\n\nReturn the dimensionality of the observed state in problem.\n\n\n\n\n\n","category":"function"},{"location":"observation/#FeedbackParticleFilters.obs_type","page":"Observation models","title":"FeedbackParticleFilters.obs_type","text":"obs_type(arg)\n\nReturns the type of the observed state in arg.  Supported argument types:\n\nAny subtype of ObservationModel\nAny subtype of AbstractFilteringProblem\n\n\n\n\n\n","category":"function"},{"location":"observation/#FeedbackParticleFilters.time_type","page":"Observation models","title":"FeedbackParticleFilters.time_type","text":"time_type(model::AbstractModel)\n\nReturns the time type of model. \n\n\n\n\n\ntime_type(model::HiddenStateModel)\n\nReturns the time type of model, e.g. DiscreteTime' orContinuousTime'.\n\n\n\n\n\n","category":"function"},{"location":"observation/#","page":"Observation models","title":"Observation models","text":"Pages = [\"observation.md\"]","category":"page"},{"location":"observation/#Diffusion-processes-1","page":"Observation models","title":"Diffusion processes","text":"","category":"section"},{"location":"observation/#","page":"Observation models","title":"Observation models","text":"DiffusionObservationModel\nLinearDiffusionObservationModel\nScalarDiffusionObservationModel\nobservation_function","category":"page"},{"location":"algorithms/#Filtering-algorithms-1","page":"Filtering algorithms","title":"Filtering algorithms","text":"","category":"section"},{"location":"algorithms/#","page":"Filtering algorithms","title":"Filtering algorithms","text":"CurrentModule = FeedbackParticleFilters","category":"page"},{"location":"algorithms/#","page":"Filtering algorithms","title":"Filtering algorithms","text":"AbstractFilteringAlgorithm,\nAbstractFilterState,\nupdate!","category":"page"},{"location":"algorithms/#","page":"Filtering algorithms","title":"Filtering algorithms","text":"Pages = [\"algorithms.md\"]","category":"page"},{"location":"algorithms/#Kalman-Bucy-filter-(KBF)-1","page":"Filtering algorithms","title":"Kalman-Bucy filter (KBF)","text":"","category":"section"},{"location":"algorithms/#","page":"Filtering algorithms","title":"Filtering algorithms","text":"KBF\nKBState","category":"page"},{"location":"algorithms/#Feedback-particle-filter-(FPF)-1","page":"Filtering algorithms","title":"Feedback particle filter (FPF)","text":"","category":"section"},{"location":"algorithms/#","page":"Filtering algorithms","title":"Filtering algorithms","text":"FPF\nFPFState","category":"page"},{"location":"gainest/#Gain-estimation-1","page":"Gain estimation","title":"Gain estimation","text":"","category":"section"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"CurrentModule = FeedbackParticleFilters","category":"page"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"GainEquation\nGainEstimationMethod\nsolve!\nupdate!","category":"page"},{"location":"gainest/#FeedbackParticleFilters.GainEquation","page":"Gain estimation","title":"FeedbackParticleFilters.GainEquation","text":"GainEquation\n\nAbstract type for a container representing a gain (vector field).\n\n\n\n\n\n","category":"type"},{"location":"gainest/#FeedbackParticleFilters.GainEstimationMethod","page":"Gain estimation","title":"FeedbackParticleFilters.GainEstimationMethod","text":"GainEstimationMethod\n\nAbstract type for a method used to solve an equation of GainEquation type.\n\n\n\n\n\n","category":"type"},{"location":"gainest/#FeedbackParticleFilters.solve!","page":"Gain estimation","title":"FeedbackParticleFilters.solve!","text":"solve!(eq::GainEquation, method::GainEstimationMethod) --> eq\n\nSolves the gain equation eq using method method.\n\n\n\n\n\n","category":"function"},{"location":"gainest/#FeedbackParticleFilters.update!","page":"Gain estimation","title":"FeedbackParticleFilters.update!","text":"update!(filter_state, filter_algo, obs, dt) --> filter_state\n\nUpdates the filter state by performing one forward step of the model and then assimilating the observation. \n\n\n\n\n\nupdate!(eq::GainEquation)\n\nUpdates the gain equation eq such that all information contained in it is self-consistent.\n\nupdate!(eq::GainEquation, ens::ParticleRepresentation)\n\nUpdates the gain equation eq by incorporating new information from the ensemble ens.\n\n\n\n\n\n","category":"function"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"Pages = [\"gainest.md\"]","category":"page"},{"location":"gainest/#Poisson-equation-1","page":"Gain estimation","title":"Poisson equation","text":"","category":"section"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"PoissonEquation","category":"page"},{"location":"gainest/#FeedbackParticleFilters.PoissonEquation","page":"Gain estimation","title":"FeedbackParticleFilters.PoissonEquation","text":"PoissonEquation(h, ensemble) ::GainEquation\n\nReturns a Poisson equation struct  representing the equation nablacdot(pnabla phi) = - tilde h, where p is a probability density and tilde h = h-int h p dx.  The container contains the following fields\n\n:h':h` itself\n:positions': an i.i.d. sample fromp`, represented as a matrix\n:H': the evaluation ofh` at the sample points\n:mean_H': the sample average ofH'\n:potential': the evaluation of\\phi` at the sample points\n:gain': the evaluation ofK=\\nabla \\phi` at the sample points\nsolve!(eq::PoissonEquation, method::GainEstimationMethod)\n\nFills the field :gain' with appropriate values. The fields:H', :mean_H', and:potential' are stored to be re-used.\n\nupdate!(eq::PoissonEquation, ensemble)\n\nFills the fields :positions',:H', and :mean_H' according to the new samples fromensemble'.\n\nupdate!(eq::PoissonEquation)\n\nUpdates fields :H', and:mean_H' to be consistent with `:positions'.\n\n\n\n\n\n","category":"type"},{"location":"gainest/#Gain-estimation-methods-1","page":"Gain estimation","title":"Gain estimation methods","text":"","category":"section"},{"location":"gainest/#","page":"Gain estimation","title":"Gain estimation","text":"ConstantGainApproximation\nSemigroupMethod\nDifferentialRKHSMethod","category":"page"},{"location":"gainest/#FeedbackParticleFilters.ConstantGainApproximation","page":"Gain estimation","title":"FeedbackParticleFilters.ConstantGainApproximation","text":"ConstantGainApproximation()\n\nRepresents an approximation of the gain by a constant (in the Euclidean sense) vector field, given by the covariance of the observation function and x under the particle distribution.\n\n\n\n\n\n","category":"type"},{"location":"gainest/#FeedbackParticleFilters.SemigroupMethod","page":"Gain estimation","title":"FeedbackParticleFilters.SemigroupMethod","text":"SemigroupMethod(epsilon, delta, max_iter)\n\nSemigroup method from Algorithm 1 in [1].\n\n[1] Taghvaei, A., & Mehta, P. G. (2016). Gain function approximation in the feedback particle filter. In 2016 IEEE 55th Conference on Decision and Control (CDC) (pp. 5446â€“5452). IEEE. https://doi.org/10.1109/CDC.2016.7799105\n\nSemigroupMethod(epsilon, delta, max_iter, lambda)\n\nSemigroup method with regularization parameter lambda.\n\n\n\n\n\n","category":"type"},{"location":"gainest/#FeedbackParticleFilters.DifferentialRKHSMethod","page":"Gain estimation","title":"FeedbackParticleFilters.DifferentialRKHSMethod","text":"DifferentialRKHSMethod1d(epsilon, lambda)\n\nDifferential loss reproducing kernel Hilbert space (RKHS) method from [1], Section III.\n\nParameters\n\nepsilon: variance of the Gaussian kernel, Eq. 17 in [1]\nlambda: regularization parameter, Eq. 20 in [1]\n\nReference\n\n[1] Radhakrishnan, A. & and Meyn, S. (2018). Feedback particle filter design using a differential-loss reproducing kernel Hilbert space. 2018 Annual American Control Conference (ACC). IEEE. https://doi.org/10.23919/ACC.2018.8431689\n\n\n\n\n\n","category":"type"}]
}
